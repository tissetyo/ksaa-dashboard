================================================================================
DATABASE SCHEMA - COMPLETE SPECIFICATION
================================================================================

TECHNOLOGY: PostgreSQL with Prisma ORM

================================================================================
SCHEMA OVERVIEW
================================================================================

Tables:
1. User - Authentication and role management
2. Patient - Patient-specific information
3. Product - STEMCARE services/treatments
4. Appointment - Booking records
5. AvailabilitySlot - Weekly recurring schedule
6. DateOverride - Special dates (holidays, closures)
7. DailyQuota - Real-time quota tracking
8. RefundRequest - Patient refund requests
9. Payment - Payment transaction records
10. Account, Session, VerificationToken - NextAuth tables

================================================================================
PRISMA SCHEMA (schema.prisma)
================================================================================

// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// AUTHENTICATION & USER MANAGEMENT
// ============================================================================

enum UserRole {
  PATIENT
  SUPERADMIN
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  password      String    // Hashed password
  role          UserRole  @default(PATIENT)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  patient   Patient?
  accounts  Account[]
  sessions  Session[]

  @@index([email])
}

// NextAuth.js required tables
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================================================
// PATIENT INFORMATION
// ============================================================================

enum BloodType {
  A_POSITIVE
  A_NEGATIVE
  B_POSITIVE
  B_NEGATIVE
  AB_POSITIVE
  AB_NEGATIVE
  O_POSITIVE
  O_NEGATIVE
  UNKNOWN
}

model Patient {
  id     String @id @default(cuid())
  userId String @unique

  // Personal Information
  fullName String
  phone    String
  address  String?

  // Physical Information
  age       Int?
  heightCm  Float?
  weightKg  Float?
  bloodType BloodType @default(UNKNOWN)

  // Emergency Contact
  emergencyContactName  String?
  emergencyContactPhone String?

  // Medical Information
  medicalAllergies     String? @db.Text
  currentMedications   String? @db.Text
  previousTreatments   String? @db.Text
  additionalNotes      String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  appointments  Appointment[]
  refundRequests RefundRequest[]

  @@index([userId])
  @@index([fullName])
  @@index([phone])
}

// ============================================================================
// PRODUCTS/SERVICES
// ============================================================================

model Product {
  id          String  @id @default(cuid())
  name        String
  description String  @db.Text
  
  // Pricing
  priceMYR         Float
  depositPercentage Int   @default(30) // 0-100, percentage for deposit option
  
  // Service Details
  durationMinutes Int
  quotaPerDay     Int   @default(5) // Max appointments per day for this service
  
  // Status
  isActive Boolean @default(true)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  appointments Appointment[]
  dailyQuotas  DailyQuota[]

  @@index([isActive])
  @@index([name])
}

// ============================================================================
// APPOINTMENTS
// ============================================================================

enum AppointmentStatus {
  PENDING       // Just created, awaiting confirmation
  CONFIRMED     // Confirmed by admin or auto-confirmed
  COMPLETED     // Service completed
  CANCELLED     // Cancelled by patient or admin
  NO_SHOW       // Patient didn't show up
}

enum PaymentStatus {
  UNPAID        // No payment made
  DEPOSIT_PAID  // Deposit paid, balance remaining
  FULL_PAID     // Fully paid
  REFUNDED      // Refunded (full or partial)
}

enum PaymentType {
  FULL    // 100% payment
  DEPOSIT // Partial payment (deposit)
}

model Appointment {
  id        String   @id @default(cuid())
  patientId String
  productId String

  // Appointment Details
  appointmentDate DateTime // Date of appointment
  timeSlot        String   // e.g., "09:00", "14:30"
  
  // Status
  status        AppointmentStatus @default(PENDING)
  paymentStatus PaymentStatus     @default(UNPAID)
  paymentType   PaymentType       @default(FULL)

  // Payment Information
  totalAmountMYR   Float
  paidAmountMYR    Float   @default(0)
  balanceAmountMYR Float   @default(0)
  
  // Stripe Integration
  stripePaymentIntentId String? @unique
  stripeRefundId        String?

  // Notifications
  reminderEmailSent    Boolean @default(false)
  reminderWhatsAppSent Boolean @default(false)

  // Admin Notes
  adminNotes String? @db.Text

  // Google Calendar
  googleCalendarEventId String? @unique

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  cancelledAt DateTime?

  // Relations
  patient        Patient         @relation(fields: [patientId], references: [id], onDelete: Cascade)
  product        Product         @relation(fields: [productId], references: [id])
  payments       Payment[]
  refundRequests RefundRequest[]

  @@index([patientId])
  @@index([productId])
  @@index([appointmentDate])
  @@index([status])
  @@index([paymentStatus])
}

// ============================================================================
// PAYMENT TRANSACTIONS
// ============================================================================

enum PaymentTransactionStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

model Payment {
  id            String @id @default(cuid())
  appointmentId String

  // Payment Details
  amountMYR             Float
  stripPaymentIntentId  String  @unique
  stripeChargeId        String?
  status                PaymentTransactionStatus @default(PENDING)

  // Metadata
  paymentMethod String? // e.g., "card", "fpx"
  currency      String  @default("MYR")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)

  @@index([appointmentId])
  @@index([stripPaymentIntentId])
}

// ============================================================================
// SCHEDULING SYSTEM
// ============================================================================

// Weekly recurring schedule
model AvailabilitySlot {
  id          String @id @default(cuid())
  
  dayOfWeek   Int    // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
  timeSlot    String // e.g., "09:00", "14:30"
  
  isActive    Boolean @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([dayOfWeek, timeSlot])
  @@index([dayOfWeek])
  @@index([isActive])
}

// Override for specific dates (holidays, special hours)
model DateOverride {
  id           String   @id @default(cuid())
  
  specificDate DateTime @unique // The date to override
  isClosed     Boolean  @default(true) // If true, clinic is closed
  reason       String?  // e.g., "Public Holiday", "Staff Training"
  
  // If not closed, can specify custom time slots (JSON array)
  customTimeSlots String? @db.Text // JSON: ["09:00", "11:00", "15:00"]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([specificDate])
}

// Real-time quota tracking per product per day
model DailyQuota {
  id          String   @id @default(cuid())
  productId   String
  bookingDate DateTime // Date for which quota applies
  
  bookedCount Int      @default(0) // Current bookings
  maxQuota    Int      // Max allowed (from Product.quotaPerDay)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, bookingDate])
  @@index([bookingDate])
  @@index([productId])
}

// ============================================================================
// REFUND MANAGEMENT
// ============================================================================

enum RefundRequestStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSED
}

model RefundRequest {
  id            String @id @default(cuid())
  appointmentId String
  patientId     String

  // Request Details
  reason              String  @db.Text
  requestedRefundMYR  Float   // Amount patient requesting
  
  // Admin Processing
  status              RefundRequestStatus @default(PENDING)
  processedByAdminId  String?
  approvedRefundMYR   Float? // Actual approved amount
  rejectionReason     String? @db.Text
  
  // Stripe
  stripeRefundId String?

  // Timestamps
  requestedAt DateTime  @default(now())
  processedAt DateTime?

  // Relations
  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  patient     Patient     @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@index([appointmentId])
  @@index([patientId])
  @@index([status])
}

================================================================================
KEY RELATIONSHIPS
================================================================================

User (1) <---> (1) Patient
User (1) <---> (Many) Account
User (1) <---> (Many) Session

Patient (1) <---> (Many) Appointment
Patient (1) <---> (Many) RefundRequest

Product (1) <---> (Many) Appointment
Product (1) <---> (Many) DailyQuota

Appointment (1) <---> (Many) Payment
Appointment (1) <---> (Many) RefundRequest

================================================================================
INDEXES FOR PERFORMANCE
================================================================================

Critical indexes created on:
- User.email (unique, for login)
- Patient.userId (unique, for user-patient relationship)
- Patient.fullName (for search)
- Patient.phone (for search)
- Appointment.appointmentDate (for date queries)
- Appointment.status (for filtering)
- Appointment.patientId (for patient queries)
- Appointment.productId (for product queries)
- DailyQuota.bookingDate (for availability checks)
- AvailabilitySlot.dayOfWeek (for schedule queries)

================================================================================
DATA CONSTRAINTS
================================================================================

1. Email must be unique across users
2. One patient per user account
3. Product quotaPerDay must be > 0
4. Appointment totalAmountMYR = Product.priceMYR at time of booking
5. BalanceAmountMYR = totalAmountMYR - paidAmountMYR
6. DailyQuota.bookedCount cannot exceed maxQuota
7. AvailabilitySlot dayOfWeek must be 0-6
8. Product depositPercentage must be 0-100

================================================================================
SAMPLE QUERIES YOU'LL NEED
================================================================================

1. Check availability for a date:
   - Get DateOverride for date
   - If not closed, get AvailabilitySlots for day of week
   - Get DailyQuota for each product on that date
   - Return available slots where bookedCount < maxQuota

2. Create appointment:
   - Verify quota available
   - Create Appointment record
   - Increment DailyQuota.bookedCount
   - Create Payment record
   - Create Google Calendar event

3. Get patient appointments:
   - Filter by patientId
   - Join with Product for details
   - Order by appointmentDate DESC

4. Get tomorrow's appointments for reminders:
   - Filter appointmentDate = tomorrow
   - Status = CONFIRMED
   - reminderEmailSent = false OR reminderWhatsAppSent = false

5. Admin dashboard stats:
   - Count appointments by status
   - Sum payments by date range
   - Count patients registered

================================================================================
MIGRATIONS
================================================================================

After creating schema.prisma:

1. npx prisma generate
2. npx prisma db push (development)
3. npx prisma migrate dev --name init (production)

================================================================================
SEEDING (Optional for Testing)
================================================================================

Create seed.ts to populate:
- 1 Super Admin user
- 3-5 Sample products
- Weekly availability slots (Mon-Fri, 9AM-5PM)
- 2-3 Sample patients
- A few test appointments

Run: npx prisma db seed

================================================================================
