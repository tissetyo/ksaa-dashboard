================================================================================
PAYMENT SYSTEM - COMPLETE SPECIFICATION (STRIPE)
================================================================================

MARKET: Malaysia (MYR currency)
PAYMENT GATEWAY: Stripe
OPTIONS: Full payment or Deposit payment

================================================================================
1. STRIPE SETUP & CONFIGURATION
================================================================================

--- STRIPE ACCOUNT SETUP ---

1. Create Stripe account for Malaysian business
   URL: https://stripe.com

2. Business verification:
   - Business name: KSAA STEMCARE
   - Country: Malaysia
   - Currency: MYR
   - Business type: Medical/Healthcare

3. Enable payment methods:
   - Credit/Debit cards (Visa, Mastercard, Amex)
   - FPX (Malaysian bank transfers) - Optional
   - Touch 'n Go eWallet - Optional

4. Get API keys:
   - Publishable Key (starts with pk_)
   - Secret Key (starts with sk_)
   - Webhook signing secret

--- ENVIRONMENT VARIABLES ---

```env
# Stripe Configuration
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_xxxxx
STRIPE_SECRET_KEY=sk_test_xxxxx
STRIPE_WEBHOOK_SECRET=whsec_xxxxx

# Stripe Currency
STRIPE_CURRENCY=myr
```

================================================================================
2. PAYMENT FLOW ARCHITECTURE
================================================================================

STEP 1: Patient selects service and date
STEP 2: Patient chooses payment option (Full or Deposit)
STEP 3: Stripe Payment Intent created
STEP 4: Patient enters card details (Stripe Elements)
STEP 5: Payment processed
STEP 6: Webhook confirms payment
STEP 7: Appointment confirmed

================================================================================
3. PAYMENT INTENT CREATION
================================================================================

File: /app/api/payments/create-intent/route.ts

```typescript
import Stripe from 'stripe';
import { db } from '@/lib/db';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
});

export async function POST(req: Request) {
  try {
    const { productId, paymentType } = await req.json();
    
    // Get product details
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    
    if (!product) {
      return Response.json({ error: 'Product not found' }, { status: 404 });
    }
    
    // Calculate amount based on payment type
    let amount: number;
    let description: string;
    
    if (paymentType === 'full') {
      amount = product.priceMYR;
      description = `Full payment for ${product.name}`;
    } else if (paymentType === 'deposit') {
      amount = product.priceMYR * (product.depositPercentage / 100);
      description = `Deposit (${product.depositPercentage}%) for ${product.name}`;
    } else {
      return Response.json({ error: 'Invalid payment type' }, { status: 400 });
    }
    
    // Create payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency: 'myr',
      description: description,
      metadata: {
        productId: productId,
        productName: product.name,
        paymentType: paymentType,
        totalPrice: product.priceMYR.toString(),
      },
      automatic_payment_methods: {
        enabled: true,
      },
    });
    
    return Response.json({
      clientSecret: paymentIntent.client_secret,
      amount: amount,
      paymentIntentId: paymentIntent.id,
    });
    
  } catch (error) {
    console.error('Payment intent creation error:', error);
    return Response.json({ error: 'Payment processing failed' }, { status: 500 });
  }
}
```

================================================================================
4. FRONTEND PAYMENT FORM
================================================================================

File: /components/payment/PaymentForm.tsx

```typescript
'use client';

import { useState } from 'react';
import { loadStripe } from '@stripe/stripe-js';
import {
  PaymentElement,
  Elements,
  useStripe,
  useElements,
} from '@stripe/react-stripe-js';

const stripePromise = loadStripe(
  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!
);

interface PaymentFormProps {
  amount: number;
  productName: string;
  paymentType: 'full' | 'deposit';
  onSuccess: (paymentIntentId: string) => void;
  onError: (error: string) => void;
}

function CheckoutForm({ onSuccess, onError }: PaymentFormProps) {
  const stripe = useStripe();
  const elements = useElements();
  const [isProcessing, setIsProcessing] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!stripe || !elements) {
      return;
    }
    
    setIsProcessing(true);
    setErrorMessage('');
    
    // Confirm payment
    const { error, paymentIntent } = await stripe.confirmPayment({
      elements,
      confirmParams: {
        return_url: `${window.location.origin}/patient/book/confirmation`,
      },
      redirect: 'if_required',
    });
    
    if (error) {
      setErrorMessage(error.message || 'Payment failed');
      onError(error.message || 'Payment failed');
      setIsProcessing(false);
    } else if (paymentIntent && paymentIntent.status === 'succeeded') {
      onSuccess(paymentIntent.id);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <PaymentElement />
      
      {errorMessage && (
        <div className="text-red-600 mt-2 text-sm">
          {errorMessage}
        </div>
      )}
      
      <button
        type="submit"
        disabled={!stripe || isProcessing}
        className="w-full mt-4 bg-blue-600 text-white py-3 rounded-lg
                   disabled:bg-gray-400 disabled:cursor-not-allowed"
      >
        {isProcessing ? 'Processing...' : 'Pay Now'}
      </button>
    </form>
  );
}

export default function PaymentForm(props: PaymentFormProps) {
  const [clientSecret, setClientSecret] = useState('');
  
  // Fetch payment intent on mount
  useEffect(() => {
    async function createPaymentIntent() {
      const res = await fetch('/api/payments/create-intent', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          productId: props.productId,
          paymentType: props.paymentType,
        }),
      });
      
      const data = await res.json();
      setClientSecret(data.clientSecret);
    }
    
    createPaymentIntent();
  }, []);
  
  if (!clientSecret) {
    return <div>Loading payment form...</div>;
  }
  
  return (
    <Elements stripe={stripePromise} options={{ clientSecret }}>
      <CheckoutForm {...props} />
    </Elements>
  );
}
```

================================================================================
5. WEBHOOK HANDLER (PAYMENT CONFIRMATION)
================================================================================

File: /app/api/webhooks/stripe/route.ts

```typescript
import { headers } from 'next/headers';
import Stripe from 'stripe';
import { db } from '@/lib/db';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
});

const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;

export async function POST(req: Request) {
  const body = await req.text();
  const signature = headers().get('stripe-signature')!;
  
  let event: Stripe.Event;
  
  try {
    event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
  } catch (err) {
    console.error('Webhook signature verification failed:', err);
    return Response.json({ error: 'Invalid signature' }, { status: 400 });
  }
  
  // Handle payment_intent.succeeded event
  if (event.type === 'payment_intent.succeeded') {
    const paymentIntent = event.data.object as Stripe.PaymentIntent;
    
    try {
      await handlePaymentSuccess(paymentIntent);
    } catch (error) {
      console.error('Error handling payment success:', error);
      return Response.json({ error: 'Processing failed' }, { status: 500 });
    }
  }
  
  // Handle payment_intent.payment_failed event
  if (event.type === 'payment_intent.payment_failed') {
    const paymentIntent = event.data.object as Stripe.PaymentIntent;
    
    try {
      await handlePaymentFailure(paymentIntent);
    } catch (error) {
      console.error('Error handling payment failure:', error);
    }
  }
  
  return Response.json({ received: true });
}

async function handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent) {
  const metadata = paymentIntent.metadata;
  
  // Find appointment by payment intent ID
  const appointment = await db.appointment.findUnique({
    where: { stripePaymentIntentId: paymentIntent.id },
    include: { product: true, patient: true }
  });
  
  if (!appointment) {
    console.error('Appointment not found for payment intent:', paymentIntent.id);
    return;
  }
  
  // Update appointment status
  const paymentType = metadata.paymentType;
  const amount = paymentIntent.amount / 100; // Convert from cents
  
  await db.appointment.update({
    where: { id: appointment.id },
    data: {
      status: 'CONFIRMED',
      paymentStatus: paymentType === 'full' ? 'FULL_PAID' : 'DEPOSIT_PAID',
      paidAmountMYR: amount,
      balanceAmountMYR: paymentType === 'deposit' 
        ? appointment.totalAmountMYR - amount 
        : 0,
    }
  });
  
  // Create payment record
  await db.payment.create({
    data: {
      appointmentId: appointment.id,
      amountMYR: amount,
      stripPaymentIntentId: paymentIntent.id,
      stripeChargeId: paymentIntent.latest_charge as string,
      status: 'SUCCEEDED',
      paymentMethod: paymentIntent.payment_method_types[0],
    }
  });
  
  // Create Google Calendar event
  // await createCalendarEvent(appointment);
  
  // Send confirmation email (add to queue)
  // await addToEmailQueue(appointment);
}

async function handlePaymentFailure(paymentIntent: Stripe.PaymentIntent) {
  // Find appointment
  const appointment = await db.appointment.findUnique({
    where: { stripePaymentIntentId: paymentIntent.id }
  });
  
  if (!appointment) return;
  
  // Delete appointment and release quota
  await db.$transaction(async (tx) => {
    await tx.appointment.delete({
      where: { id: appointment.id }
    });
    
    await tx.dailyQuota.update({
      where: {
        productId_bookingDate: {
          productId: appointment.productId,
          bookingDate: appointment.appointmentDate,
        }
      },
      data: {
        bookedCount: { decrement: 1 }
      }
    });
  });
}
```

================================================================================
6. REFUND PROCESSING
================================================================================

File: /app/api/admin/refunds/process/route.ts

```typescript
import Stripe from 'stripe';
import { db } from '@/lib/db';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
});

export async function POST(req: Request) {
  try {
    const { refundRequestId, approvedAmount, adminId } = await req.json();
    
    // Get refund request with appointment
    const refundRequest = await db.refundRequest.findUnique({
      where: { id: refundRequestId },
      include: { 
        appointment: {
          include: { payments: true }
        }
      }
    });
    
    if (!refundRequest) {
      return Response.json({ error: 'Refund request not found' }, { status: 404 });
    }
    
    const appointment = refundRequest.appointment;
    const payment = appointment.payments[0]; // Get first payment
    
    if (!payment || !payment.stripPaymentIntentId) {
      return Response.json({ error: 'No payment found' }, { status: 400 });
    }
    
    // Process refund via Stripe
    const refund = await stripe.refunds.create({
      payment_intent: payment.stripPaymentIntentId,
      amount: Math.round(approvedAmount * 100), // Convert to cents
      reason: 'requested_by_customer',
      metadata: {
        appointmentId: appointment.id,
        refundRequestId: refundRequestId,
      }
    });
    
    // Update refund request
    await db.refundRequest.update({
      where: { id: refundRequestId },
      data: {
        status: 'PROCESSED',
        approvedRefundMYR: approvedAmount,
        stripeRefundId: refund.id,
        processedByAdminId: adminId,
        processedAt: new Date(),
      }
    });
    
    // Update appointment payment status
    await db.appointment.update({
      where: { id: appointment.id },
      data: {
        paymentStatus: 'REFUNDED'
      }
    });
    
    // Update payment record
    await db.payment.update({
      where: { id: payment.id },
      data: {
        status: 'REFUNDED'
      }
    });
    
    return Response.json({
      success: true,
      refundId: refund.id,
      amount: approvedAmount
    });
    
  } catch (error) {
    console.error('Refund processing error:', error);
    return Response.json({ error: 'Refund failed' }, { status: 500 });
  }
}
```

================================================================================
7. REFUND POLICY CALCULATION
================================================================================

File: /lib/refund-policy.ts

```typescript
export function calculateRefundAmount(
  appointment: Appointment,
  cancelledAt: Date = new Date()
): number {
  
  const appointmentDate = new Date(appointment.appointmentDate);
  const daysDifference = Math.floor(
    (appointmentDate.getTime() - cancelledAt.getTime()) / (1000 * 60 * 60 * 24)
  );
  
  const paidAmount = appointment.paidAmountMYR;
  
  // Refund policy:
  // >7 days before: 100% refund
  // 3-7 days before: 50% refund
  // <3 days before: No refund
  
  if (daysDifference > 7) {
    return paidAmount; // 100%
  } else if (daysDifference >= 3) {
    return paidAmount * 0.5; // 50%
  } else {
    return 0; // No refund
  }
}

export function getRefundPolicyText(daysDifference: number): string {
  if (daysDifference > 7) {
    return 'Full refund (100%) - Cancelled more than 7 days before appointment';
  } else if (daysDifference >= 3) {
    return 'Partial refund (50%) - Cancelled 3-7 days before appointment';
  } else {
    return 'No refund - Cancelled less than 3 days before appointment';
  }
}
```

================================================================================
8. PAYMENT TYPES & SCENARIOS
================================================================================

--- FULL PAYMENT ---

Amount: 100% of product price
Balance: RM 0.00
Status after payment: FULL_PAID

Example:
Product: STEMCARE Facial (RM 450.00)
Patient pays: RM 450.00
Balance due: RM 0.00

--- DEPOSIT PAYMENT ---

Amount: X% of product price (configurable per product)
Balance: Remaining amount
Status after payment: DEPOSIT_PAID

Example:
Product: STEMCARE Facial (RM 450.00)
Deposit: 30%
Patient pays: RM 135.00
Balance due: RM 315.00

Balance Payment:
- Paid at clinic (cash/card)
- Admin marks as "Balance Paid"
- Status changes to FULL_PAID

================================================================================
9. PAYMENT RECEIPT GENERATION
================================================================================

File: /lib/generate-receipt.ts

```typescript
export function generatePaymentReceipt(appointment: Appointment, payment: Payment) {
  return {
    receiptNumber: `KSAA-${appointment.id.slice(-8).toUpperCase()}`,
    date: payment.createdAt.toLocaleDateString('en-MY'),
    patientName: appointment.patient.fullName,
    service: appointment.product.name,
    appointmentDate: appointment.appointmentDate.toLocaleDateString('en-MY'),
    
    payment: {
      amount: `RM ${payment.amountMYR.toFixed(2)}`,
      method: payment.paymentMethod,
      transactionId: payment.stripPaymentIntentId,
      status: 'Paid'
    },
    
    summary: {
      total: `RM ${appointment.totalAmountMYR.toFixed(2)}`,
      paid: `RM ${appointment.paidAmountMYR.toFixed(2)}`,
      balance: `RM ${appointment.balanceAmountMYR.toFixed(2)}`,
    },
    
    clinic: {
      name: 'KSAA STEMCARE',
      address: 'Your clinic address',
      phone: 'Your phone number',
      email: 'Your email'
    }
  };
}
```

================================================================================
10. ERROR HANDLING
================================================================================

Common Errors & Solutions:

ERROR: "Card declined"
Solution: Ask patient to use different card or payment method

ERROR: "Insufficient funds"
Solution: Patient needs to use card with sufficient balance

ERROR: "Payment processing timeout"
Solution: Check Stripe dashboard, don't duplicate booking

ERROR: "Webhook not received"
Solution: Implement retry logic, check webhook logs in Stripe

ERROR: "Amount mismatch"
Solution: Validate amount on server before creating PaymentIntent

================================================================================
11. TESTING STRIPE INTEGRATION
================================================================================

--- TEST MODE ---

Use Stripe test mode during development:
- Test publishable key: pk_test_xxx
- Test secret key: sk_test_xxx

--- TEST CARDS ---

Success:
- 4242 4242 4242 4242 (Visa)
- 5555 5555 5555 4444 (Mastercard)

Decline:
- 4000 0000 0000 0002 (Card declined)

3D Secure:
- 4000 0025 0000 3155 (Requires authentication)

--- TEST SCENARIOS ---

1. Successful full payment
2. Successful deposit payment
3. Card declined
4. Payment cancelled by user
5. Webhook received correctly
6. Refund processed successfully
7. Partial refund
8. Concurrent payments (race condition)

================================================================================
12. STRIPE DASHBOARD USAGE
================================================================================

Admin should check Stripe Dashboard for:

1. Payment confirmation
2. Refund processing
3. Transaction details
4. Dispute resolution
5. Failed payment reasons
6. Webhook logs

URL: https://dashboard.stripe.com

================================================================================
13. SECURITY BEST PRACTICES
================================================================================

1. NEVER expose secret key in frontend
2. Use HTTPS in production
3. Validate webhook signatures
4. Store sensitive data encrypted
5. Implement rate limiting on payment endpoints
6. Log all payment transactions
7. Monitor for suspicious activity
8. Use Stripe's fraud detection tools

================================================================================
14. PAYMENT FLOW DIAGRAM
================================================================================

Patient Side:
1. Select service & date
2. Choose payment type
3. Enter card details (Stripe Elements)
4. Click "Pay Now"
5. Wait for confirmation
6. Receive receipt

Backend:
1. Create PaymentIntent (server)
2. Return client secret
3. Process payment (Stripe)
4. Send webhook (Stripe â†’ Server)
5. Verify webhook signature
6. Update appointment status
7. Create payment record
8. Create calendar event
9. Send confirmation email

Admin Side:
1. View payment in dashboard
2. Process refunds if requested
3. Mark balance as paid (for deposits)
4. Generate reports

================================================================================
15. DATABASE PAYMENT RECORDS
================================================================================

Every payment creates TWO records:

1. Appointment table:
   - paymentStatus
   - totalAmountMYR
   - paidAmountMYR
   - balanceAmountMYR
   - stripePaymentIntentId

2. Payment table:
   - appointmentId
   - amountMYR
   - stripPaymentIntentId
   - stripeChargeId
   - status
   - paymentMethod

This provides:
- Transaction history
- Audit trail
- Easy refund tracking
- Financial reporting

================================================================================
